# ostle_solver

https://gamemarket.jp/game/76310

※Ostle（オストル）は 雅ゲームスにより制作されたボードゲームです。当リポジトリと雅ゲームスとの関係はありません。

cf:
http://h1.hara.net.it-chiba.ac.jp/ostle/

ｶﾞﾊﾞｱﾙｶﾓ

## 局面の全列挙

まず最初に、初期局面から到達可能な局面を全列挙して、その総数（あるいはその上界）を求めた。

### 全列挙の定義

- 対称な局面は同一視する。
- 手番側が即座に勝利できる局面までを含み、その手を指して勝利した後の局面は含めない。
- 手番側が即座に勝利できる局面でも、その手を指さなくてもよいとする。言い換えると、どこかで勝利を見逃さないと決して辿り着けないような局面も含める。

### 考察

25マスあるとき、最初に穴1個を配置して、残り24マスに手番側のコマ5or4個と相手のコマ5or4個を配置する、と解釈する。このとき穴の配置箇所として考慮すべき場所は、下図で"o"になっている6マス（実装上の番号では0,1,2,6,7,12）だけである。なぜなら、他のマスに穴を配置した場合、その後でコマをどのように配置しようとも、結果生じる盤面に対して対称な盤面が、列挙した盤面のなかに必ず含まれるからである。

| 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
| o | o | o | . | . |
| . | o | o | . | . |
| . | . | o | . | . |
| . | . | . | . | . |
| . | . | . | . | . |

逆に言うと、上記の6マスのうち別の穴に配置した2つの盤面同士は、決して対称にならない。また手番側or相手のコマの数が異なる盤面同士も決して対称にならない。ゆえに、穴の位置6通り * コマの数4通り = 24通りに、全局面を排他的かつ網羅的に分割できるといえる。対称性もその分割の内側同士でだけ考慮すればよい。

### 現状

初期局面から到達可能な全局面を探索によって列挙するコードができたが、終わらない。（実行時間数分・メモリ消費量4GBとかでひとまず打ち切った）unordered_setが実行時間の少なくとも4割を占めているっぽい。

簡単なpythonのコードで局面数の上界を求めたところ、21,880,262,250局面以下であることがわかった。（対称性を考慮していないし、勝利を見逃さないと辿り着けない局面を含んでいる）

その21,880,262,250局面を力まかせに全列挙して、対称性を考慮しつつハッシュテーブルに入れていくことが考えられる。あるいは、対称性を考慮せずに単にvector<uint64_t>に入れるのも考えられる。前者より後者のほうがじつは省メモリな可能性は捨てきれなくて、なぜなら(1) 対称性を考慮しても局面数は半分くらいにしか減らないと推察される（なぜならそもそも大多数の局面は対称でないので）し、 (2) ハッシュテーブルにはメモリ消費量のオーバーヘッドがあるから。

### undo関数の必要性について

盤面pのポインタと指し手mを引数に取り、mを指して盤面をp'に更新する関数をdo関数と呼ぶ。逆に、p'のポインタとmを引数に取りp'をpに戻す関数をundo関数と呼ぶ。

将棋ソフトとかではこのように1個の盤面データを破壊的変更しながら探索するのが普通である。そのような方式を取る理由はそのほうが速いからだが、背景事情として (1) pのデータ構造が大きい (2) 手を指すことによる盤面の変更が局所的である (3) 評価関数を差分評価するときの差分更新も(un)do関数のタイミングで行う などがある。

今回はundo関数を実装してしまったが、結局使わなかった。全列挙するだけなので差分評価とかは無いわけだが、そういう背景の違いを検討せずになんとなく実装してしまったのだった。
